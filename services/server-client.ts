//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/";
    }

    /**
     * @return Success
     */
    gpt(): Promise<void> {
        let url_ = this.baseUrl + "/Gpt";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGpt(_response);
        });
    }

    protected processGpt(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    articleSummarizer(body: CommonGptRequest | undefined): Promise<WorkResponse> {
        let url_ = this.baseUrl + "/Gpt/article-summarizer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArticleSummarizer(_response);
        });
    }

    protected processArticleSummarizer(response: Response): Promise<WorkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    paragraphGenerator(body: CommonGptRequest | undefined): Promise<WorkResponse> {
        let url_ = this.baseUrl + "/Gpt/paragraph-generator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParagraphGenerator(_response);
        });
    }

    protected processParagraphGenerator(response: Response): Promise<WorkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    convertCode(body: ConvertCodeRequest | undefined): Promise<WorkResponse> {
        let url_ = this.baseUrl + "/Gpt/convert-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConvertCode(_response);
        });
    }

    protected processConvertCode(response: Response): Promise<WorkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    smartContractGenerator(body: SmartContractGeneratorRequest | undefined): Promise<WorkResponse> {
        let url_ = this.baseUrl + "/Gpt/smart-contract-generator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSmartContractGenerator(_response);
        });
    }

    protected processSmartContractGenerator(response: Response): Promise<WorkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    uiComponentGenerator(body: UIComponentGeneratorRequest | undefined): Promise<WorkResponse> {
        let url_ = this.baseUrl + "/Gpt/ui-component-generator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUiComponentGenerator(_response);
        });
    }

    protected processUiComponentGenerator(response: Response): Promise<WorkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    textToImageGenerator(body: TextToImageGeneratorRequest | undefined): Promise<WorkResponse> {
        let url_ = this.baseUrl + "/Gpt/text-to-image-generator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTextToImageGenerator(_response);
        });
    }

    protected processTextToImageGenerator(response: Response): Promise<WorkResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkResponse>(null as any);
    }

    /**
     * @return Success
     */
    status(gptId: string): Promise<StatusResponse> {
        let url_ = this.baseUrl + "/Polling/status/{gptId}";
        if (gptId === undefined || gptId === null)
            throw new Error("The parameter 'gptId' must be defined.");
        url_ = url_.replace("{gptId}", encodeURIComponent("" + gptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<StatusResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusResponse>(null as any);
    }

    /**
     * @return Success
     */
    results(gptId: string): Promise<ResultsResponse> {
        let url_ = this.baseUrl + "/Polling/results/{gptId}";
        if (gptId === undefined || gptId === null)
            throw new Error("The parameter 'gptId' must be defined.");
        url_ = url_.replace("{gptId}", encodeURIComponent("" + gptId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResults(_response);
        });
    }

    protected processResults(response: Response): Promise<ResultsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultsResponse>(null as any);
    }

    /**
     * @return Success
     */
    stripe(): Promise<void> {
        let url_ = this.baseUrl + "/Stripe";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStripe(_response);
        });
    }

    protected processStripe(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    webhook(): Promise<void> {
        let url_ = this.baseUrl + "/Stripe/webhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWebhook(_response);
        });
    }

    protected processWebhook(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CommonGptRequest implements ICommonGptRequest {
    inputText?: string | undefined;

    constructor(data?: ICommonGptRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inputText = _data["inputText"];
        }
    }

    static fromJS(data: any): CommonGptRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CommonGptRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputText"] = this.inputText;
        return data;
    }
}

export interface ICommonGptRequest {
    inputText?: string | undefined;
}

export class ConvertCodeRequest implements IConvertCodeRequest {
    codeToConvert?: string | undefined;
    fromProgrammingLanguage?: string | undefined;
    toProgrammingLanguage?: string | undefined;

    constructor(data?: IConvertCodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.codeToConvert = _data["codeToConvert"];
            this.fromProgrammingLanguage = _data["fromProgrammingLanguage"];
            this.toProgrammingLanguage = _data["toProgrammingLanguage"];
        }
    }

    static fromJS(data: any): ConvertCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConvertCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["codeToConvert"] = this.codeToConvert;
        data["fromProgrammingLanguage"] = this.fromProgrammingLanguage;
        data["toProgrammingLanguage"] = this.toProgrammingLanguage;
        return data;
    }
}

export interface IConvertCodeRequest {
    codeToConvert?: string | undefined;
    fromProgrammingLanguage?: string | undefined;
    toProgrammingLanguage?: string | undefined;
}

export class ResultsResponse implements IResultsResponse {
    resultUrl?: string | undefined;

    constructor(data?: IResultsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resultUrl = _data["resultUrl"];
        }
    }

    static fromJS(data: any): ResultsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resultUrl"] = this.resultUrl;
        return data;
    }
}

export interface IResultsResponse {
    resultUrl?: string | undefined;
}

export class SmartContractGeneratorRequest implements ISmartContractGeneratorRequest {
    blockchain?: string | undefined;
    tokenStandard?: string | undefined;
    contractName?: string | undefined;
    whatDoesItDo?: string | undefined;

    constructor(data?: ISmartContractGeneratorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.blockchain = _data["blockchain"];
            this.tokenStandard = _data["tokenStandard"];
            this.contractName = _data["contractName"];
            this.whatDoesItDo = _data["whatDoesItDo"];
        }
    }

    static fromJS(data: any): SmartContractGeneratorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SmartContractGeneratorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blockchain"] = this.blockchain;
        data["tokenStandard"] = this.tokenStandard;
        data["contractName"] = this.contractName;
        data["whatDoesItDo"] = this.whatDoesItDo;
        return data;
    }
}

export interface ISmartContractGeneratorRequest {
    blockchain?: string | undefined;
    tokenStandard?: string | undefined;
    contractName?: string | undefined;
    whatDoesItDo?: string | undefined;
}

export class StatusResponse implements IStatusResponse {
    status?: string | undefined;

    constructor(data?: IStatusResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): StatusResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StatusResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IStatusResponse {
    status?: string | undefined;
}

export class TextToImageGeneratorRequest implements ITextToImageGeneratorRequest {
    concept?: string | undefined;
    size?: string | undefined;

    constructor(data?: ITextToImageGeneratorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.concept = _data["concept"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): TextToImageGeneratorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TextToImageGeneratorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["concept"] = this.concept;
        data["size"] = this.size;
        return data;
    }
}

export interface ITextToImageGeneratorRequest {
    concept?: string | undefined;
    size?: string | undefined;
}

export class UIComponentGeneratorRequest implements IUIComponentGeneratorRequest {
    nameOfComponent?: string | undefined;
    webFrameworkUsed?: string | undefined;
    uiLibraryUsed?: string | undefined;
    purposeOfComponent?: string | undefined;
    howIsComponentIsStyled?: string | undefined;
    web3WalletFeatureUsed?: string | undefined;

    constructor(data?: IUIComponentGeneratorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameOfComponent = _data["nameOfComponent"];
            this.webFrameworkUsed = _data["webFrameworkUsed"];
            this.uiLibraryUsed = _data["uiLibraryUsed"];
            this.purposeOfComponent = _data["purposeOfComponent"];
            this.howIsComponentIsStyled = _data["howIsComponentIsStyled"];
            this.web3WalletFeatureUsed = _data["web3WalletFeatureUsed"];
        }
    }

    static fromJS(data: any): UIComponentGeneratorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UIComponentGeneratorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameOfComponent"] = this.nameOfComponent;
        data["webFrameworkUsed"] = this.webFrameworkUsed;
        data["uiLibraryUsed"] = this.uiLibraryUsed;
        data["purposeOfComponent"] = this.purposeOfComponent;
        data["howIsComponentIsStyled"] = this.howIsComponentIsStyled;
        data["web3WalletFeatureUsed"] = this.web3WalletFeatureUsed;
        return data;
    }
}

export interface IUIComponentGeneratorRequest {
    nameOfComponent?: string | undefined;
    webFrameworkUsed?: string | undefined;
    uiLibraryUsed?: string | undefined;
    purposeOfComponent?: string | undefined;
    howIsComponentIsStyled?: string | undefined;
    web3WalletFeatureUsed?: string | undefined;
}

export class WorkResponse implements IWorkResponse {
    workGuid?: string | undefined;

    constructor(data?: IWorkResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workGuid = _data["workGuid"];
        }
    }

    static fromJS(data: any): WorkResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workGuid"] = this.workGuid;
        return data;
    }
}

export interface IWorkResponse {
    workGuid?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}